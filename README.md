# My Solutions to Common Leetcode Problems
This repository contains my solutions to various coding problems on LeetCode. The primary goal of this repository is not just to provide solutions, but also to explain the rationale behind them and discuss the complexities involved.

## Repository Structure
Each solution file is named after the LeetCode problem number and title, making it easy to search for specific problems. For instance, `1-two-sum.py` contains the solution to the problem "Two Sum."

## Solutions
The solutions provided in this repository are implemented using Python. Each solution is accompanied by comments that explain the approach and any complexities or edge cases considered.

### Examples
Below are examples of how the solutions are structured:

- **Problem 001: Two Sum**
  - **Solution:** [001_Two_Sum.py](./001_Two_Sum.py)
  - **Approach:** This solution utilizes a hashmap to track the indices of the numbers as we iterate through the list, allowing us to find the complement of each number efficiently.

## Personal Notes on Problem Solving
This section is dedicated to sharing my personal insights and strategies that I've found helpful while solving problems on LeetCode. I'll update this section as I continue to complete more problems and learn new techniques.

### Problem Solving Tips
- **Understand the Problem:** Make sure you fully understand the problem and all its requirements before starting to code. Drawing a picture is very helpful
- **Devise a Plan:** Think about different approaches to solve the problem, considering time and space complexities.
- **Simplify Things:** Break down the problem into smaller, manageable parts or try to solve a simpler version of the problem first.
- **Debugging:** Always check edge cases and use print statements to debug and understand the flow of your solution.

## Methodology for Solving Problems
The approach to solving problems on LeetCode in this repository is inspired by systematic problem-solving strategies used in physics. 

### Step 1: Identify
- **Understand the Problem:** Read the problem statement carefully to fully grasp what's being asked.
- **Identify Key Variables:** Determine the output you need to produce and any specific input values that the problem provides or implies.
- **Predict Outcomes:** Before coding, think about what the results might be for given examples. This can help guide your solution approach.

### Step 2: Set Up
- **Choose the Right Tools:** Based on the problem's requirements, decide whether you need a data structure like a hashmap, or a specific sorting or searching algorithm.
- **Draw a Sketch:** For complex problems, sketching out the data flow or component interactions can be incredibly helpful. Use comments in your code to outline sections or logic flow.
- **Plan Your Code:** Outline your function or classes, thinking about how the components interact, and what libraries or built-in functions might be useful.

### Step 3: Execute
- **Code the Solution:** Write your code, implementing the logic you've planned out in the setup phase.
- **Test as You Go:** Run tests with sample inputs (both given and your own test cases) to make sure each part of your solution works correctly before moving on.

### Step 4: Evaluate
- **Compare Results:** Once your solution runs, compare the outputs with your initial predictions. If there's a discrepancy, revisit your understanding of the problem or your implementation.
- **Check Extremes:** Test how your solution behaves with edge cases or extreme values. This includes very large inputs, very small inputs, or unusual combinations.
- **Reflect and Generalize:** Think about how your solution can be adapted or improved. Could it handle a more complex version of the same problem? What if the constraints were changed?


## License
This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.
